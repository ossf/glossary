<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OpenSSF Glossary – Fundamental</title><link>https://glossary.openssf.org/tags/fundamental/</link><description>Recent content in Fundamental on OpenSSF Glossary</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://glossary.openssf.org/tags/fundamental/index.xml" rel="self" type="application/rss+xml"/><item><title>: Artifact</title><link>https://glossary.openssf.org/artifact/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/artifact/</guid><description>
&lt;p>Artifacts are work products that are produced and used during a project to capture and convey information (e.g., models, source code).&lt;/p>
&lt;p>An artifact can also be a piece of evidence, such as text or a reference to a resource, that is submitted to support a response to a question.&lt;/p>
&lt;p>Source: &lt;a href="https://csrc.nist.gov/glossary/term/artifact">https://csrc.nist.gov/glossary/term/artifact&lt;/a>&lt;/p></description></item><item><title>: Attestation</title><link>https://glossary.openssf.org/attestation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/attestation/</guid><description>
&lt;p>The issue of a statement, based on a decision, that fulfillment of specified requirements has been demonstrated. In cyber security it can be a review and confirmation of a project or organization&amp;rsquo;s security status.&lt;/p>
&lt;p>Source: &lt;a href="https://csrc.nist.gov/glossary/term/attestation">https://csrc.nist.gov/glossary/term/attestation&lt;/a>&lt;/p></description></item><item><title>: Authentication</title><link>https://glossary.openssf.org/authentication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/authentication/</guid><description>
&lt;p>Verifying the identity of a user, process, or device, often as a prerequisite to allowing access to resources in an information system.&lt;/p>
&lt;p>Source: &lt;a href="https://csrc.nist.gov/glossary/term/authentication">https://csrc.nist.gov/glossary/term/authentication&lt;/a>&lt;/p></description></item><item><title>: Authorization</title><link>https://glossary.openssf.org/authorization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/authorization/</guid><description>
&lt;p>Giving an authenticated user, process or device permission to access to resources in an information system.&lt;/p></description></item><item><title>: Availability</title><link>https://glossary.openssf.org/availability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/availability/</guid><description>
&lt;p>Timely and reliable access to and use of information.&lt;/p>
&lt;p>Source: &lt;a href="https://csrc.nist.gov/glossary/term/availability">https://csrc.nist.gov/glossary/term/availability&lt;/a>&lt;/p></description></item><item><title>: Capabilities</title><link>https://glossary.openssf.org/capabilities/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/capabilities/</guid><description>
&lt;p>Linux kernel uses capabilities to compartmentalize the UNIX root privilege into a set of non-overlapping sub privileges (called capabilities) that can be individually assigned where higher granularity than root/non-root is suitable.&lt;/p>
&lt;p>Reference for capabilities list: &lt;a href="https://man7.org/linux/man-pages/man7/capabilities.7.html">https://man7.org/linux/man-pages/man7/capabilities.7.html&lt;/a>&lt;/p></description></item><item><title>: CI/CD Pipeline (Continuous Integration and Continuous Delivery)</title><link>https://glossary.openssf.org/ci-cd-pipeline/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/ci-cd-pipeline/</guid><description>
&lt;p>A process that automates the building, testing, and deployment of software. CI/CD stands for continuous integration and continuous delivery. Continuous integration is the practice of integrating code changes as regularly as possible. Continuous delivery is a set of practices in which code changes are automatically deployed into an acceptance environment.&lt;/p></description></item><item><title>: CIA Triad</title><link>https://glossary.openssf.org/cia-triad/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/cia-triad/</guid><description>
&lt;p>The CIA triad represents the three pillars of information security: confidentiality, integrity, and availability, as follows.&lt;/p>
&lt;p>Confidentiality – preserving authorized restrictions on information access and disclosure, including means for protecting personal privacy and proprietary information&lt;/p>
&lt;p>Integrity – guarding against improper information modification or destruction and ensuring information non-repudiation and authenticity&lt;/p>
&lt;p>Availability – ensuring timely and reliable access to and use of information&lt;/p>
&lt;p>Source: &lt;a href="https://www.nccoe.nist.gov/publication/1800-26/VolA/index.html">https://www.nccoe.nist.gov/publication/1800-26/VolA/index.html&lt;/a>&lt;/p></description></item><item><title>: Code Review</title><link>https://glossary.openssf.org/code-review/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/code-review/</guid><description>
&lt;p>Code review is a software quality assurance activity in which one or more people examine the source code of a computer program.&lt;/p></description></item><item><title>: Code Scanning</title><link>https://glossary.openssf.org/code-scanning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/code-scanning/</guid><description>
&lt;p>Code scanning is the process of using tools to analyze the source code of a computer program for potential security flaws, bugs, and other issues.&lt;/p></description></item><item><title>: Common Vulnerabilities and Exposures (CVE)</title><link>https://glossary.openssf.org/common-vulnerabilities-exposures/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/common-vulnerabilities-exposures/</guid><description>
&lt;p>A list of publicly disclosed computer security flaws. When someone refers to a CVE, they mean a security flaw assigned a CVE ID number. The mission of the CVE Program is to identify, define, and catalog publicly disclosed cyber security vulnerabilities. There is one CVE Record for each vulnerability in the catalog. The vulnerabilities are discovered then assigned and published by organizations from around the world that have partnered with the CVE Program. Partners publish CVE Records to communicate consistent descriptions of vulnerabilities. Information technology and cyber security professionals use CVE Records to ensure they are discussing the same issue, and to coordinate their efforts to prioritize and address the vulnerabilities.&lt;/p>
&lt;p>Source: &lt;a href="https://www.cve.org/About/Overview">https://www.cve.org/About/Overview&lt;/a>&lt;/p></description></item><item><title>: Common Vulnerability Scoring System (CVSS)</title><link>https://glossary.openssf.org/common-vulnerability-scoring-system/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/common-vulnerability-scoring-system/</guid><description>
&lt;p>&amp;ldquo;The Common Vulnerability Scoring System (CVSS) provides a way to capture the principal characteristics of a vulnerability and produce a numerical score reflecting its severity. The numerical score can then be translated into a qualitative representation (such as low, medium, high, and critical) to help organizations properly assess and prioritize their vulnerability management processes.&amp;rdquo;&lt;/p>
&lt;p>The &lt;a href="https://www.first.org/cvss/">FIRST&lt;/a> CVSS SIG gathers feedback to
improve the CVSS.&lt;/p>
&lt;p>CVSS provides a simple estimate of a vulnerability&amp;rsquo;s
severity from a few principal characteristics. However,
the ultimate importance to an organization of some software
vulnerability depends on many details of exactly how the software is
used; no simple system like CVSS can fully capture this.
Many find CVSS helpful (since there are &lt;em>many&lt;/em> known vulnerabilities).
However, do not assume that a vulnerability with a critical severity is &lt;em>always&lt;/em>
truly critical to your organization, and do not assume that a vulnerability
with medium severity &lt;em>always&lt;/em> less important to your organization.&lt;/p>
&lt;p>Source: &lt;a href="https://www.first.org/cvss/">https://www.first.org/cvss/&lt;/a>&lt;/p></description></item><item><title>: Common Weakness Enumeration (CWE)</title><link>https://glossary.openssf.org/common-weakness-enumeration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/common-weakness-enumeration/</guid><description>
&lt;p>&amp;ldquo;Common Weakness Enumeration (CWE™) is a community-developed list
of common software and hardware weaknesses. A “weakness” is a
condition in a software, firmware, hardware, or service component
that, under certain circumstances, could contribute to the introduction
of vulnerabilities.&amp;rdquo;&lt;/p>
&lt;p>Examples of CWEs are:&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;Improper Neutralization of Input During Web
Page Generation (&amp;lsquo;Cross-site Scripting&amp;rsquo;)&amp;rdquo; (CWE-79),&lt;/li>
&lt;li>&amp;ldquo;Out-of-bounds Write&amp;rdquo; (CWE-787)&lt;/li>
&lt;li>&amp;ldquo;Improper Neutralization of Special Elements used in an SQL Command
(&amp;lsquo;SQL Injection&amp;rsquo;)&amp;rdquo; (CWE-89)&lt;/li>
&lt;/ul>
&lt;p>Each CWE identifies a &lt;em>type&lt;/em> of vulnerability.
A specific vulnerability in a specific product, once publicly known,
would receive a &lt;em>CVE&lt;/em> identifier (not a CWE identifier).&lt;/p>
&lt;p>Source: &lt;a href="https://cwe.mitre.org/about/index.html">https://cwe.mitre.org/about/index.html&lt;/a>&lt;/p></description></item><item><title>: Confidentiality</title><link>https://glossary.openssf.org/confidentiality/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/confidentiality/</guid><description>
&lt;p>The property that sensitive information is not disclosed to
unauthorized entities.&lt;/p>
&lt;p>Source: &lt;a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-152.pdf">https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-152.pdf&lt;/a>&lt;/p></description></item><item><title>: Critical Information Infrastructure (CII)</title><link>https://glossary.openssf.org/critical-information-infrastructure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/critical-information-infrastructure/</guid><description>
&lt;p>Critical Information Infrastructure (CII) constitutes assets (real/virtual), networks, systems, processes, information, and functions that are vital to a nation such that their incapacity or destruction would have a devastating impact on national security, the economic and social well-being of citizens. CII may comprise a number of different infrastructures with essential interdependencies and critical information flows between them.&lt;/p>
&lt;p>Source: &lt;a href="https://www.cisa.gov/topics/critical-infrastructure-security-and-resilience/critical-infrastructure-sectors">https://www.cisa.gov/topics/critical-infrastructure-security-and-resilience/critical-infrastructure-sectors&lt;/a>&lt;/p></description></item><item><title>: DAST</title><link>https://glossary.openssf.org/dast/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/dast/</guid><description>
&lt;p>DAST is an acronym for Dynamic Application Security Testing.&lt;/p>
&lt;p>There is agreement that DAST executes a program (that is, it uses dynamic analysis instead of static analysis) to find vulnerabilities. However, while the term DAST is often seen in the literature, the &lt;em>meaning&lt;/em> of DAST has variation in industry.&lt;/p>
&lt;p>By some definitions, DAST is dynamic analysis for finding vulnerabilities in (only) web applications (see VeraCode, &lt;a href="https://www.veracode.com/security/dast-test">&lt;em>DAST TEST: Benefits of a DAST test for application security&lt;/em>&lt;/a>, 2020). This makes the term DAST mostly equivalent to the use of &lt;em>web application scanners&lt;/em>. John Breeden II (&lt;a href="https://www.csoonline.com/article/3487708/9-top-fuzzing-tools-finding-the-weirdest-application-errors.html">&lt;em>9 top fuzzing tools: Finding the weirdest application errors&lt;/em>&lt;/a>, 2019) states this and expressly differentiates DAST from fuzzing.&lt;/p>
&lt;p>Others definitions use the term DAST more broadly, where dynamic analysis is used to find vulnerabilities where the &amp;ldquo;tester has no [necessary] prior knowledge of the system&amp;rdquo;. Under this definition, DAST includes web application scanners, fuzzers, and other dynamic approaches that can be applied to applications. Examples include Thomas Scanlon (&lt;a href="https://insights.sei.cmu.edu/sei_blog/2018/07/10-types-of-application-security-testing-tools-when-and-how-to-use-them.html">&lt;em>10 Types of Application Security Testing Tools: When and How to Use Them&lt;/em>&lt;/a>, 2018) and Sergej Dechand (&lt;a href="https://blog.code-intelligence.com/what-is-fast">&lt;em>What is FAST?&lt;/em>&lt;/a>, 2020) includes web application scanners and fuzzers under “DAST”.&lt;/p>
&lt;p>&lt;a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-204C.pdf">NIST Special Publication 800-204C&lt;/a>
attempts to split the difference, defining DAST as analyzing
&amp;ldquo;applications in their dynamic, running state during testing or
operational phases. They simulate attacks against an application
(typically web-enabled applications, services, and APIs), analyze
the application’s reactions, and determine whether it is vulnerable.&amp;rdquo;&lt;/p>
&lt;p>Source: &lt;a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-204C.pdf">https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-204C.pdf&lt;/a>&lt;/p></description></item><item><title>: Fuzzing</title><link>https://glossary.openssf.org/fuzzing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/fuzzing/</guid><description>
&lt;p>Fuzzing, also called fuzz testing, is an automated verification technique that involves providing invalid, unexpected, or random data as inputs to a computer program. The program is executed and monitored for exceptions such as crashes, failing built-in code assertions, or potential memory leaks.&lt;/p>
&lt;p>Fuzz testing differs from traditional software testing. A traditional software tests sends a known input, executes the program, and verifies that the output is correct. Traditional software tests are much more sensitive to incorrect outputs, but these tests take time to create because the correct output must be determined (requiring an &amp;ldquo;oracle&amp;rdquo;). Fuzz testing abandons the need to know the correct output, making it easy to apply many more inputs but reducing the ability to detect errors in each execution. Many systems use traditional software testing to check basic functionality and combine that with fuzzing to attempt to detect problems like security vulnerabilities.&lt;/p>
&lt;p>The term &amp;ldquo;fuzz&amp;rdquo; and the concept of fuzz testing originates from work by Prof. Barton Miller at the University of Wisconsin published in 1990.&lt;/p>
&lt;p>Source: &lt;a href="https://en.wikipedia.org/w/index.php?title=Fuzzing&amp;oldid=1270167521">https://en.wikipedia.org/w/index.php?title=Fuzzing&amp;oldid=1270167521&lt;/a>&lt;/p></description></item><item><title>: Hardening</title><link>https://glossary.openssf.org/hardening/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/hardening/</guid><description>
&lt;p>&amp;ldquo;Security hardening is the process of enhancing the security posture
of a system or network by implementing a series of proactive measures
to reduce vulnerabilities and mitigate potential risks. This includes
configuring systems, applications, and infrastructure to adhere to
best security practices, such as disabling unnecessary services,
enforcing strong authentication mechanisms, applying patches and
updates regularly, and configuring firewalls and intrusion detection
systems. The goal of security hardening is to minimize the attack
surface and strengthen defenses against cyber threats, reducing the
likelihood of successful attacks and enhancing overall resilience
to security breaches and unauthorized access.&amp;rdquo;&lt;/p>
&lt;p>Some definitions are narrower, for example,
&lt;a href="https://csrc.nist.gov/glossary/term/hardening">NIST SP 800-152&lt;/a>
defines hardening as
&amp;ldquo;a process intended to eliminate a means of attack by patching vulnerabilities and turning off nonessential services.&amp;rdquo;
However, even if it doesn&amp;rsquo;t &lt;em>eliminate&lt;/em> some means of attack, we consider
processes that reduce vulnerabilities and mitigate potential risks as
hardening.&lt;/p>
&lt;p>See
&lt;a href="https://best.openssf.org/Compiler-Hardening-Guides/Compiler-Options-Hardening-Guide-for-C-and-C++.html">OpenSSF &amp;ldquo;Compiler Options Hardening Guide for C and C++&amp;rdquo;&lt;/a> for compiler options for hardening C and C++ programs.&lt;/p>
&lt;p>Source: &lt;a href="https://www.atera.com/glossary/security-hardening/">https://www.atera.com/glossary/security-hardening/&lt;/a>&lt;/p></description></item><item><title>: Integrity</title><link>https://glossary.openssf.org/integrity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/integrity/</guid><description>
&lt;p>A property whereby data has not been altered in an
unauthorized manner since it was created, transmitted, or stored.&lt;/p>
&lt;p>Source: &lt;a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-152.pdf">https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-152.pdf&lt;/a>&lt;/p></description></item><item><title>: Negative Testing</title><link>https://glossary.openssf.org/negative-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/negative-testing/</guid><description>
&lt;p>Negative testing, also called “error path testing” or “invalid input
testing,” is a software testing methodology that evaluates how
systems and applications handle unexpected inputs and conditions.
This is contrasted with positive testing, that is, testing the &amp;ldquo;happy path&amp;rdquo;
initiated by expected inputs.&lt;/p>
&lt;p>Negative testing includes testing to ensure that what should not happen
does not happen. This is vital for security.
For example, if a user should not be able to delete an object owned by another
user, it&amp;rsquo;s important to &lt;em>test&lt;/em> this is the case.
If a field is supposed to only provide a number, a negative test should
ensure that non-numbers are rejected.
Many test suites only test the &amp;ldquo;happy path&amp;rdquo; of expected values.
Many security properties are negative (&amp;ldquo;X should never happen&amp;rdquo;), so failing to
apply negative testing can lead to serious security vulnerabilities.&lt;/p>
&lt;p>Source: &lt;a href="https://www.ranorex.com/blog/positive-testing-vs-negative-testing-key-differences/">https://www.ranorex.com/blog/positive-testing-vs-negative-testing-key-differences/&lt;/a>&lt;/p></description></item><item><title>: Object code</title><link>https://glossary.openssf.org/object-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/object-code/</guid><description>
&lt;p>Object code is a form of a work that is not source code.&lt;/p>
&lt;p>A build process converts source code into object code.&lt;/p>
&lt;p>Source: &lt;a href="https://www.gnu.org/licenses/gpl-3.0.en.html">https://www.gnu.org/licenses/gpl-3.0.en.html&lt;/a>&lt;/p></description></item><item><title>: Reproducible Build</title><link>https://glossary.openssf.org/reproducible-build/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/reproducible-build/</guid><description>
&lt;p>A build is &lt;em>reproducible&lt;/em> if given the same source code, any party can recreate bit-by-bit identical copies of all specified artifacts. Information about the build environment and build instructions is usually needed to achieve that. This creates an independently-verifiable path from source to binary code and counters attacks on the build process.&lt;/p>
&lt;p>A &lt;em>verified&lt;/em> reproducible build is a build result that has been independently verified to reproduce. Verified reproducible builds allow multiple third parties to come to a consensus on a “correct” result, highlighting any deviations as suspect and worthy of scrutiny. See &lt;a href="https://reproducible-builds.org/docs/">https://reproducible-builds.org/docs/&lt;/a> for tips on how to achieve reproducible builds.&lt;/p>
&lt;p>Source: &lt;a href="https://reproducible-builds.org/docs/definition/">https://reproducible-builds.org/docs/definition/&lt;/a>&lt;/p></description></item><item><title>: Source code</title><link>https://glossary.openssf.org/source-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://glossary.openssf.org/source-code/</guid><description>
&lt;p>Source code is the preferred form of the work for making modifications to it.&lt;/p>
&lt;p>A build process converts source code into object code.&lt;/p>
&lt;p>Source: &lt;a href="https://www.gnu.org/licenses/gpl-3.0.en.html">https://www.gnu.org/licenses/gpl-3.0.en.html&lt;/a>&lt;/p></description></item></channel></rss>